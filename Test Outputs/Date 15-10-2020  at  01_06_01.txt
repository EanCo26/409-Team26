File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Animal.java
Class Name: AnimalTP: [// Whether the animal is alive or not.
private boolean alive;, // The animal's field.
private Field field;, // The animal's position in the field.
private Location location;, /**
 * Create a new animal at location in field.
 *
 * @param field The field currently occupied.
 * @param location The location within the field.
 */
public Animal(Field field, Location location) {
    alive = true;
    this.field = field;
    setLocation(location);
}, /**
 * Make this animal act - that is: make it do
 * whatever it wants/needs to do.
 * @param newAnimals A list to receive newly born animals.
 */
abstract public void act(List<Animal> newAnimals);, /**
 * Check whether the animal is alive or not.
 * @return true if the animal is still alive.
 */
protected boolean isAlive() {
    return alive;
}, /**
 * Indicate that the animal is no longer alive.
 * It is removed from the field.
 */
protected void setDead() {
    alive = false;
    if (location != null) {
        field.clear(location);
        location = null;
        field = null;
    }
}, /**
 * Return the animal's location.
 * @return The animal's location.
 */
protected Location getLocation() {
    return location;
}, /**
 * Place the animal at the new location in the given field.
 * @param newLocation The animal's new location.
 */
protected void setLocation(Location newLocation) {
    if (location != null) {
        field.clear(location);
    }
    location = newLocation;
    field.place(this, newLocation);
}, /**
 * Return the animal's field.
 * @return The animal's field.
 */
protected Field getField() {
    return field;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Counter.java
Class Name: CounterTP: [// A name for this type of simulation participant
private String name;, // How many of this type exist in the simulation.
private int count;, /**
 * Provide a name for one of the simulation types.
 * @param name  A name, e.g. "Fox".
 */
public Counter(String name) {
    this.name = name;
    count = 0;
}, /**
 * @return The short description of this type.
 */
public String getName() {
    return name;
}, /**
 * @return The current count for this type.
 */
public int getCount() {
    return count;
}, /**
 * Increment the current count by one.
 */
public void increment() {
    count++;
}, /**
 * Reset the current count to zero.
 */
public void reset() {
    count = 0;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Field.java
Class Name: FieldTP: [// A random number generator for providing random locations.
private static final Random rand = Randomizer.getRandom();, // The depth and width of the field.
private int depth, width;, // Storage for the animals.
private Object[][] field;, /**
 * Represent a field of the given dimensions.
 * @param depth The depth of the field.
 * @param width The width of the field.
 */
public Field(int depth, int width) {
    this.depth = depth;
    this.width = width;
    field = new Object[depth][width];
}, /**
 * Empty the field.
 */
public void clear() {
    for (int row = 0; row < depth; row++) {
        for (int col = 0; col < width; col++) {
            field[row][col] = null;
        }
    }
}, /**
 * Clear the given location.
 * @param location The location to clear.
 */
public void clear(Location location) {
    field[location.getRow()][location.getCol()] = null;
}, /**
 * Place an animal at the given location.
 * If there is already an animal at the location it will
 * be lost.
 * @param animal The animal to be placed.
 * @param row Row coordinate of the location.
 * @param col Column coordinate of the location.
 */
public void place(Object animal, int row, int col) {
    place(animal, new Location(row, col));
}, /**
 * Place an animal at the given location.
 * If there is already an animal at the location it will
 * be lost.
 * @param animal The animal to be placed.
 * @param location Where to place the animal.
 */
public void place(Object animal, Location location) {
    field[location.getRow()][location.getCol()] = animal;
}, /**
 * Return the animal at the given location, if any.
 * @param location Where in the field.
 * @return The animal at the given location, or null if there is none.
 */
public Object getObjectAt(Location location) {
    return getObjectAt(location.getRow(), location.getCol());
}, /**
 * Return the animal at the given location, if any.
 * @param row The desired row.
 * @param col The desired column.
 * @return The animal at the given location, or null if there is none.
 */
public Object getObjectAt(int row, int col) {
    return field[row][col];
}, /**
 * Generate a random location that is adjacent to the
 * given location, or is the same location.
 * The returned location will be within the valid bounds
 * of the field.
 * @param location The location from which to generate an adjacency.
 * @return A valid location within the grid area.
 */
public Location randomAdjacentLocation(Location location) {
    List<Location> adjacent = adjacentLocations(location);
    return adjacent.get(0);
}, /**
 * Get a shuffled list of the free adjacent locations.
 * @param location Get locations adjacent to this.
 * @return A list of free adjacent locations.
 */
public List<Location> getFreeAdjacentLocations(Location location) {
    List<Location> free = new LinkedList<>();
    List<Location> adjacent = adjacentLocations(location);
    for (Location next : adjacent) {
        if (getObjectAt(next) == null) {
            free.add(next);
        }
    }
    return free;
}, /**
 * Try to find a free location that is adjacent to the
 * given location. If there is none, return null.
 * The returned location will be within the valid bounds
 * of the field.
 * @param location The location from which to generate an adjacency.
 * @return A valid location within the grid area.
 */
public Location freeAdjacentLocation(Location location) {
    // The available free ones.
    List<Location> free = getFreeAdjacentLocations(location);
    if (free.size() > 0) {
        return free.get(0);
    } else {
        return null;
    }
}, /**
 * Return a shuffled list of locations adjacent to the given one.
 * The list will not include the location itself.
 * All locations will lie within the grid.
 * @param location The location from which to generate adjacencies.
 * @return A list of locations adjacent to that given.
 */
public List<Location> adjacentLocations(Location location) {
    assert location != null : "Null location passed to adjacentLocations";
    // The list of locations to be returned.
    List<Location> locations = new LinkedList<>();
    if (location != null) {
        int row = location.getRow();
        int col = location.getCol();
        for (int roffset = -1; roffset <= 1; roffset++) {
            int nextRow = row + roffset;
            if (nextRow >= 0 && nextRow < depth) {
                for (int coffset = -1; coffset <= 1; coffset++) {
                    int nextCol = col + coffset;
                    // Exclude invalid locations and the original location.
                    if (nextCol >= 0 && nextCol < width && (roffset != 0 || coffset != 0)) {
                        locations.add(new Location(nextRow, nextCol));
                    }
                }
            }
        }
        // Shuffle the list. Several other methods rely on the list
        // being in a random order.
        Collections.shuffle(locations, rand);
    }
    return locations;
}, /**
 * Return the depth of the field.
 * @return The depth of the field.
 */
public int getDepth() {
    return depth;
}, /**
 * Return the width of the field.
 * @return The width of the field.
 */
public int getWidth() {
    return width;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\FieldStats.java
Class Name: FieldStatsTP: [// Counters for each type of entity (fox, rabbit, etc.) in the simulation.
private HashMap<Class, Counter> counters;, // Whether the counters are currently up to date.
private boolean countsValid;, /**
 * Construct a FieldStats object.
 */
public FieldStats() {
    // Set up a collection for counters for each type of animal that
    // we might find
    counters = new HashMap<>();
    countsValid = false;
}, /**
 * Get details of what is in the field.
 * @return A string describing what is in the field.
 */
public String getPopulationDetails(Field field) {
    StringBuffer buffer = new StringBuffer();
    if (!countsValid) {
        generateCounts(field);
    }
    for (Class key : counters.keySet()) {
        Counter info = counters.get(key);
        buffer.append(info.getName());
        buffer.append(": ");
        buffer.append(info.getCount());
        buffer.append(' ');
    }
    return buffer.toString();
}, /**
 * Get the number of individuals in the population of a given class.
 * @return  An int with the number for this class.
 */
public int getPopulationCount(Field field, Class key) {
    if (!countsValid) {
        generateCounts(field);
    }
    Counter counter = counters.get(key);
    return counter.getCount();
}, /**
 * Invalidate the current set of statistics; reset all
 * counts to zero.
 */
public void reset() {
    countsValid = false;
    for (Class key : counters.keySet()) {
        Counter count = counters.get(key);
        count.reset();
    }
}, /**
 * Increment the count for one class of animal.
 * @param animalClass The class of animal to increment.
 */
public void incrementCount(Class animalClass) {
    Counter count = counters.get(animalClass);
    if (count == null) {
        // We do not have a counter for this species yet.
        // Create one.
        count = new Counter(animalClass.getName());
        counters.put(animalClass, count);
    }
    count.increment();
}, /**
 * Indicate that an animal count has been completed.
 */
public void countFinished() {
    countsValid = true;
}, /**
 * Determine whether the simulation is still viable.
 * I.e., should it continue to run.
 * @return true If there is more than one species alive.
 */
public boolean isViable(Field field) {
    // How many counts are non-zero.
    int nonZero = 0;
    if (!countsValid) {
        generateCounts(field);
    }
    for (Class key : counters.keySet()) {
        Counter info = counters.get(key);
        if (info.getCount() > 0) {
            nonZero++;
        }
    }
    return nonZero > 1;
}, /**
 * Generate counts of the number of foxes and rabbits.
 * These are not kept up to date as foxes and rabbits
 * are placed in the field, but only when a request
 * is made for the information.
 * @param field The field to generate the stats for.
 */
private void generateCounts(Field field) {
    reset();
    for (int row = 0; row < field.getDepth(); row++) {
        for (int col = 0; col < field.getWidth(); col++) {
            Object animal = field.getObjectAt(row, col);
            if (animal != null) {
                incrementCount(animal.getClass());
            }
        }
    }
    countsValid = true;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Fox.java
Class Name: FoxTP: [// Characteristics shared by all foxes (class variables).
// The age at which a fox can start to breed.
private static final int BREEDING_AGE = 15;, // The age to which a fox can live.
private static final int MAX_AGE = 150;, // The likelihood of a fox breeding.
private static final double BREEDING_PROBABILITY = 0.08;, // The maximum number of births.
private static final int MAX_LITTER_SIZE = 2;, // The food value of a single rabbit. In effect, this is the
// number of steps a fox can go before it has to eat again.
private static final int RABBIT_FOOD_VALUE = 9;, // A shared random number generator to control breeding.
private static final Random rand = Randomizer.getRandom();, // Individual characteristics (instance fields).
// The fox's age.
private int age;, // The fox's food level, which is increased by eating rabbits.
private int foodLevel;, /**
 * Create a fox. A fox can be created as a new born (age zero
 * and not hungry) or with a random age and food level.
 *
 * @param randomAge If true, the fox will have random age and hunger level.
 * @param field The field currently occupied.
 * @param location The location within the field.
 */
public Fox(boolean randomAge, Field field, Location location) {
    super(field, location);
    if (randomAge) {
        age = rand.nextInt(MAX_AGE);
        foodLevel = rand.nextInt(RABBIT_FOOD_VALUE);
    } else {
        age = 0;
        foodLevel = RABBIT_FOOD_VALUE;
    }
}, /**
 * This is what the fox does most of the time: it hunts for
 * rabbits. In the process, it might breed, die of hunger,
 * or die of old age.
 * @param field The field currently occupied.
 * @param newFoxes A list to return newly born foxes.
 */
public void act(List<Animal> newFoxes) {
    incrementAge();
    incrementHunger();
    if (isAlive()) {
        giveBirth(newFoxes);
        // Move towards a source of food if found.
        Location newLocation = findFood();
        if (newLocation == null) {
            // No food found - try to move to a free location.
            newLocation = getField().freeAdjacentLocation(getLocation());
        }
        // See if it was possible to move.
        if (newLocation != null) {
            setLocation(newLocation);
        } else {
            // Overcrowding.
            setDead();
        }
    }
}, /**
 * Increase the age. This could result in the fox's death.
 */
private void incrementAge() {
    age++;
    if (age > MAX_AGE) {
        setDead();
    }
}, /**
 * Make this fox more hungry. This could result in the fox's death.
 */
private void incrementHunger() {
    foodLevel--;
    if (foodLevel <= 0) {
        setDead();
    }
}, /**
 * Look for rabbits adjacent to the current location.
 * Only the first live rabbit is eaten.
 * @return Where food was found, or null if it wasn't.
 */
private Location findFood() {
    Field field = getField();
    List<Location> adjacent = field.adjacentLocations(getLocation());
    Iterator<Location> it = adjacent.iterator();
    while (it.hasNext()) {
        Location where = it.next();
        Object animal = field.getObjectAt(where);
        if (animal instanceof Rabbit) {
            Rabbit rabbit = (Rabbit) animal;
            if (rabbit.isAlive()) {
                rabbit.setDead();
                foodLevel = RABBIT_FOOD_VALUE;
                return where;
            }
        }
    }
    return null;
}, /**
 * Check whether or not this fox is to give birth at this step.
 * New births will be made into free adjacent locations.
 * @param newFoxes A list to return newly born foxes.
 */
private void giveBirth(List<Animal> newFoxes) {
    // New foxes are born into adjacent locations.
    // Get a list of adjacent free locations.
    Field field = getField();
    List<Location> free = field.getFreeAdjacentLocations(getLocation());
    int births = breed();
    for (int b = 0; b < births && free.size() > 0; b++) {
        Location loc = free.remove(0);
        Fox young = new Fox(false, field, loc);
        newFoxes.add(young);
    }
}, /**
 * Generate a number representing the number of births,
 * if it can breed.
 * @return The number of births (may be zero).
 */
private int breed() {
    int births = 0;
    if (canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
        births = rand.nextInt(MAX_LITTER_SIZE) + 1;
    }
    return births;
}, /**
 * A fox can breed if it has reached the breeding age.
 */
private boolean canBreed() {
    return age >= BREEDING_AGE;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\GraphView.java
Class Name: GraphViewTP: [private static final Color LIGHT_GRAY = new Color(0, 0, 0, 40);, private static JFrame frame;, private static GraphPanel graph;, private static JLabel stepLabel;, private static JLabel countLabel;, // The classes being tracked by this view
private Set<Class<?>> classes;, // A map for storing colors for participants in the simulation
private Map<Class<?>, Color> colors;, // A statistics object computing and storing simulation information
private FieldStats stats;, /**
 * Constructor.
 *
 * @param width The width of the plotter window (in pixels).
 * @param height The height of the plotter window (in pixels).
 * @param startMax The initial maximum value for the y axis.
 */
public GraphView(int width, int height, int startMax) {
    stats = new FieldStats();
    classes = new HashSet<>();
    colors = new HashMap<>();
    if (frame == null) {
        frame = makeFrame(width, height, startMax);
    } else {
        graph.newRun();
    }
// showStatus(0, null);
}, /**
 * Define a color to be used for a given class of animal.
 * @param animalClass The animal's Class object.
 * @param color The color to be used for the given class.
 */
public void setColor(Class<?> animalClass, Color color) {
    colors.put(animalClass, color);
    classes = colors.keySet();
}, /**
 * Show the current status of the field. The status is shown by displaying a line graph for
 * two classes in the field. This view currently does not work for more (or fewer) than exactly
 * two classes. If the field contains more than two different types of animal, only two of the classes
 * will be plotted.
 *
 * @param step Which iteration step it is.
 * @param field The field whose status is to be displayed.
 */
public void showStatus(int step, Field field) {
    graph.update(step, field, stats);
}, /**
 * Determine whether the simulation should continue to run.
 * @return true If there is more than one species alive.
 */
public boolean isViable(Field field) {
    return stats.isViable(field);
}, /**
 * Prepare for a new run.
 */
public void reset() {
    stats.reset();
    graph.newRun();
}, /**
 * Prepare the frame for the graph display.
 */
private JFrame makeFrame(int width, int height, int startMax) {
    JFrame frame = new JFrame("Graph View");
    frame.setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
    Container contentPane = frame.getContentPane();
    graph = new GraphPanel(width, height, startMax);
    contentPane.add(graph, BorderLayout.CENTER);
    JPanel bottom = new JPanel();
    bottom.add(new JLabel("Step:"));
    stepLabel = new JLabel("");
    bottom.add(stepLabel);
    countLabel = new JLabel(" ");
    bottom.add(countLabel);
    contentPane.add(bottom, BorderLayout.SOUTH);
    frame.pack();
    frame.setLocation(20, 600);
    frame.setVisible(true);
    return frame;
}, // ============================================================================
/**
 * Nested class: a component to display the graph.
 */
class GraphPanel extends JComponent {

    private static final double SCALE_FACTOR = 0.8;

    // An internal image buffer that is used for painting. For
    // actual display, this image buffer is then copied to screen.
    private BufferedImage graphImage;

    private int lastVal1, lastVal2;

    private int yMax;

    /**
     * Create a new, empty GraphPanel.
     */
    public GraphPanel(int width, int height, int startMax) {
        graphImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
        clearImage();
        lastVal1 = height;
        lastVal2 = height;
        yMax = startMax;
    }

    /**
     * Indicate a new simulation run on this panel.
     */
    public void newRun() {
        int height = graphImage.getHeight();
        int width = graphImage.getWidth();
        Graphics g = graphImage.getGraphics();
        g.copyArea(4, 0, width - 4, height, -4, 0);
        g.setColor(Color.BLACK);
        g.drawLine(width - 4, 0, width - 4, height);
        g.drawLine(width - 2, 0, width - 2, height);
        lastVal1 = height;
        lastVal2 = height;
        repaint();
    }

    /**
     * Dispay a new point of data.
     */
    public void update(int step, Field field, FieldStats stats) {
        if (classes.size() >= 2) {
            Iterator<Class<?>> it = classes.iterator();
            Class<?> class1 = it.next();
            Class<?> class2 = it.next();
            stats.reset();
            int count1 = stats.getPopulationCount(field, class1);
            int count2 = stats.getPopulationCount(field, class2);
            Graphics g = graphImage.getGraphics();
            int height = graphImage.getHeight();
            int width = graphImage.getWidth();
            // move graph one pixel to left
            g.copyArea(1, 0, width - 1, height, -1, 0);
            // calculate y, check whether it's out of screen. scale down if necessary.
            int y = height - ((height * count1) / yMax) - 1;
            while (y < 0) {
                scaleDown();
                y = height - ((height * count1) / yMax) - 1;
            }
            g.setColor(LIGHT_GRAY);
            g.drawLine(width - 2, y, width - 2, height);
            g.setColor(colors.get(class1));
            g.drawLine(width - 3, lastVal1, width - 2, y);
            lastVal1 = y;
            y = height - ((height * count2) / yMax) - 1;
            while (y < 0) {
                scaleDown();
                y = height - ((height * count2) / yMax) - 1;
            }
            g.setColor(LIGHT_GRAY);
            g.drawLine(width - 2, y, width - 2, height);
            g.setColor(colors.get(class2));
            g.drawLine(width - 3, lastVal2, width - 2, y);
            lastVal2 = y;
            repaint();
            stepLabel.setText("" + step);
            countLabel.setText(stats.getPopulationDetails(field));
        }
    }

    /**
     * Scale the current graph down vertically to make more room at the top.
     */
    public void scaleDown() {
        Graphics g = graphImage.getGraphics();
        int height = graphImage.getHeight();
        int width = graphImage.getWidth();
        BufferedImage tmpImage = new BufferedImage(width, (int) (height * SCALE_FACTOR), BufferedImage.TYPE_INT_RGB);
        Graphics2D gtmp = (Graphics2D) tmpImage.getGraphics();
        gtmp.scale(1.0, SCALE_FACTOR);
        gtmp.drawImage(graphImage, 0, 0, null);
        int oldTop = (int) (height * (1.0 - SCALE_FACTOR));
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, width, oldTop);
        g.drawImage(tmpImage, 0, oldTop, null);
        yMax = (int) (yMax / SCALE_FACTOR);
        lastVal1 = oldTop + (int) (lastVal1 * SCALE_FACTOR);
        lastVal2 = oldTop + (int) (lastVal2 * SCALE_FACTOR);
        repaint();
    }

    /**
     * Clear the image on this panel.
     */
    final public void clearImage() {
        Graphics g = graphImage.getGraphics();
        g.setColor(Color.WHITE);
        g.fillRect(0, 0, graphImage.getWidth(), graphImage.getHeight());
        repaint();
    }

    // The following methods are redefinitions of methods
    // inherited from superclasses.
    /**
     * Tell the layout manager how big we would like to be.
     * (This method gets called by layout managers for placing
     * the components.)
     *
     * @return The preferred dimension for this component.
     */
    public Dimension getPreferredSize() {
        return new Dimension(graphImage.getWidth(), graphImage.getHeight());
    }

    /**
     * This component is opaque.
     */
    public boolean isOpaque() {
        return true;
    }

    /**
     * This component needs to be redisplayed. Copy the internal image
     * to screen. (This method gets called by the Swing screen painter
     * every time it want this component displayed.)
     *
     * @param g The graphics context that can be used to draw on this component.
     */
    public void paintComponent(Graphics g) {
        if (graphImage != null) {
            g.drawImage(graphImage, 0, 0, null);
        }
    }
}]Class Name: GraphPanelTP: [private static final double SCALE_FACTOR = 0.8;, // An internal image buffer that is used for painting. For
// actual display, this image buffer is then copied to screen.
private BufferedImage graphImage;, private int lastVal1, lastVal2;, private int yMax;, /**
 * Create a new, empty GraphPanel.
 */
public GraphPanel(int width, int height, int startMax) {
    graphImage = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB);
    clearImage();
    lastVal1 = height;
    lastVal2 = height;
    yMax = startMax;
}, /**
 * Indicate a new simulation run on this panel.
 */
public void newRun() {
    int height = graphImage.getHeight();
    int width = graphImage.getWidth();
    Graphics g = graphImage.getGraphics();
    g.copyArea(4, 0, width - 4, height, -4, 0);
    g.setColor(Color.BLACK);
    g.drawLine(width - 4, 0, width - 4, height);
    g.drawLine(width - 2, 0, width - 2, height);
    lastVal1 = height;
    lastVal2 = height;
    repaint();
}, /**
 * Dispay a new point of data.
 */
public void update(int step, Field field, FieldStats stats) {
    if (classes.size() >= 2) {
        Iterator<Class<?>> it = classes.iterator();
        Class<?> class1 = it.next();
        Class<?> class2 = it.next();
        stats.reset();
        int count1 = stats.getPopulationCount(field, class1);
        int count2 = stats.getPopulationCount(field, class2);
        Graphics g = graphImage.getGraphics();
        int height = graphImage.getHeight();
        int width = graphImage.getWidth();
        // move graph one pixel to left
        g.copyArea(1, 0, width - 1, height, -1, 0);
        // calculate y, check whether it's out of screen. scale down if necessary.
        int y = height - ((height * count1) / yMax) - 1;
        while (y < 0) {
            scaleDown();
            y = height - ((height * count1) / yMax) - 1;
        }
        g.setColor(LIGHT_GRAY);
        g.drawLine(width - 2, y, width - 2, height);
        g.setColor(colors.get(class1));
        g.drawLine(width - 3, lastVal1, width - 2, y);
        lastVal1 = y;
        y = height - ((height * count2) / yMax) - 1;
        while (y < 0) {
            scaleDown();
            y = height - ((height * count2) / yMax) - 1;
        }
        g.setColor(LIGHT_GRAY);
        g.drawLine(width - 2, y, width - 2, height);
        g.setColor(colors.get(class2));
        g.drawLine(width - 3, lastVal2, width - 2, y);
        lastVal2 = y;
        repaint();
        stepLabel.setText("" + step);
        countLabel.setText(stats.getPopulationDetails(field));
    }
}, /**
 * Scale the current graph down vertically to make more room at the top.
 */
public void scaleDown() {
    Graphics g = graphImage.getGraphics();
    int height = graphImage.getHeight();
    int width = graphImage.getWidth();
    BufferedImage tmpImage = new BufferedImage(width, (int) (height * SCALE_FACTOR), BufferedImage.TYPE_INT_RGB);
    Graphics2D gtmp = (Graphics2D) tmpImage.getGraphics();
    gtmp.scale(1.0, SCALE_FACTOR);
    gtmp.drawImage(graphImage, 0, 0, null);
    int oldTop = (int) (height * (1.0 - SCALE_FACTOR));
    g.setColor(Color.WHITE);
    g.fillRect(0, 0, width, oldTop);
    g.drawImage(tmpImage, 0, oldTop, null);
    yMax = (int) (yMax / SCALE_FACTOR);
    lastVal1 = oldTop + (int) (lastVal1 * SCALE_FACTOR);
    lastVal2 = oldTop + (int) (lastVal2 * SCALE_FACTOR);
    repaint();
}, /**
 * Clear the image on this panel.
 */
final public void clearImage() {
    Graphics g = graphImage.getGraphics();
    g.setColor(Color.WHITE);
    g.fillRect(0, 0, graphImage.getWidth(), graphImage.getHeight());
    repaint();
}, // The following methods are redefinitions of methods
// inherited from superclasses.
/**
 * Tell the layout manager how big we would like to be.
 * (This method gets called by layout managers for placing
 * the components.)
 *
 * @return The preferred dimension for this component.
 */
public Dimension getPreferredSize() {
    return new Dimension(graphImage.getWidth(), graphImage.getHeight());
}, /**
 * This component is opaque.
 */
public boolean isOpaque() {
    return true;
}, /**
 * This component needs to be redisplayed. Copy the internal image
 * to screen. (This method gets called by the Swing screen painter
 * every time it want this component displayed.)
 *
 * @param g The graphics context that can be used to draw on this component.
 */
public void paintComponent(Graphics g) {
    if (graphImage != null) {
        g.drawImage(graphImage, 0, 0, null);
    }
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\GridView.java
Class Name: GridViewTP: [// Colors used for empty locations.
private static final Color EMPTY_COLOR = Color.white;, // Color used for objects that have no defined color.
private static final Color UNKNOWN_COLOR = Color.gray;, private final String STEP_PREFIX = "Step: ";, private final String POPULATION_PREFIX = "Population: ";, private JLabel stepLabel, population;, private FieldView fieldView;, // A map for storing colors for participants in the simulation
private Map<Class<?>, Color> colors;, // A statistics object computing and storing simulation information
private FieldStats stats;, /**
 * Create a view of the given width and height.
 * @param height The simulation's height.
 * @param width  The simulation's width.
 */
public GridView(int height, int width) {
    stats = new FieldStats();
    colors = new HashMap<>();
    setTitle("Fox and Rabbit Simulation");
    stepLabel = new JLabel(STEP_PREFIX, JLabel.CENTER);
    population = new JLabel(POPULATION_PREFIX, JLabel.CENTER);
    setLocation(20, 50);
    fieldView = new FieldView(height, width);
    Container contents = getContentPane();
    contents.add(stepLabel, BorderLayout.NORTH);
    contents.add(fieldView, BorderLayout.CENTER);
    contents.add(population, BorderLayout.SOUTH);
    pack();
    setVisible(true);
}, /**
 * Define a color to be used for a given class of animal.
 * @param animalClass The animal's Class object.
 * @param color The color to be used for the given class.
 */
public void setColor(Class<?> animalClass, Color color) {
    colors.put(animalClass, color);
}, /**
 * @return The color to be used for a given class of animal.
 */
private Color getColor(Class<?> animalClass) {
    Color col = colors.get(animalClass);
    if (col == null) {
        // no color defined for this class
        return UNKNOWN_COLOR;
    } else {
        return col;
    }
}, /**
 * Show the current status of the field.
 * @param step Which iteration step it is.
 * @param field The field whose status is to be displayed.
 */
public void showStatus(int step, Field field) {
    if (!isVisible()) {
        setVisible(true);
    }
    stepLabel.setText(STEP_PREFIX + step);
    stats.reset();
    fieldView.preparePaint();
    for (int row = 0; row < field.getDepth(); row++) {
        for (int col = 0; col < field.getWidth(); col++) {
            Object animal = field.getObjectAt(row, col);
            if (animal != null) {
                Class<?> cls = animal.getClass();
                stats.incrementCount(cls);
                fieldView.drawMark(col, row, getColor(cls));
            } else {
                fieldView.drawMark(col, row, EMPTY_COLOR);
            }
        }
    }
    stats.countFinished();
    population.setText(POPULATION_PREFIX + stats.getPopulationDetails(field));
    fieldView.repaint();
}, /**
 * Determine whether the simulation should continue to run.
 * @return true If there is more than one species alive.
 */
public boolean isViable(Field field) {
    return stats.isViable(field);
}, /**
 * Prepare for a new run.
 */
public void reset() {
    stats.reset();
}, /**
 * Provide a graphical view of a rectangular field. This is
 * a nested class (a class defined inside a class) which
 * defines a custom component for the user interface. This
 * component displays the field.
 * This is rather advanced GUI stuff - you can ignore this
 * for your project if you like.
 */
private class FieldView extends JPanel {

    private final int GRID_VIEW_SCALING_FACTOR = 6;

    private int gridWidth, gridHeight;

    private int xScale, yScale;

    Dimension size;

    private Graphics g;

    private Image fieldImage;

    /**
     * Create a new FieldView component.
     */
    public FieldView(int height, int width) {
        gridHeight = height;
        gridWidth = width;
        size = new Dimension(0, 0);
    }

    /**
     * Tell the GUI manager how big we would like to be.
     */
    public Dimension getPreferredSize() {
        return new Dimension(gridWidth * GRID_VIEW_SCALING_FACTOR, gridHeight * GRID_VIEW_SCALING_FACTOR);
    }

    /**
     * Prepare for a new round of painting. Since the component
     * may be resized, compute the scaling factor again.
     */
    public void preparePaint() {
        if (!size.equals(getSize())) {
            // if the size has changed...
            size = getSize();
            fieldImage = fieldView.createImage(size.width, size.height);
            g = fieldImage.getGraphics();
            xScale = size.width / gridWidth;
            if (xScale < 1) {
                xScale = GRID_VIEW_SCALING_FACTOR;
            }
            yScale = size.height / gridHeight;
            if (yScale < 1) {
                yScale = GRID_VIEW_SCALING_FACTOR;
            }
        }
    }

    /**
     * Paint on grid location on this field in a given color.
     */
    public void drawMark(int x, int y, Color color) {
        g.setColor(color);
        g.fillRect(x * xScale, y * yScale, xScale - 1, yScale - 1);
    }

    /**
     * The field view component needs to be redisplayed. Copy the
     * internal image to screen.
     */
    public void paintComponent(Graphics g) {
        if (fieldImage != null) {
            Dimension currentSize = getSize();
            if (size.equals(currentSize)) {
                g.drawImage(fieldImage, 0, 0, null);
            } else {
                // Rescale the previous image.
                g.drawImage(fieldImage, 0, 0, currentSize.width, currentSize.height, null);
            }
        }
    }
}]Class Name: FieldViewTP: [private final int GRID_VIEW_SCALING_FACTOR = 6;, private int gridWidth, gridHeight;, private int xScale, yScale;, Dimension size;, private Graphics g;, private Image fieldImage;, /**
 * Create a new FieldView component.
 */
public FieldView(int height, int width) {
    gridHeight = height;
    gridWidth = width;
    size = new Dimension(0, 0);
}, /**
 * Tell the GUI manager how big we would like to be.
 */
public Dimension getPreferredSize() {
    return new Dimension(gridWidth * GRID_VIEW_SCALING_FACTOR, gridHeight * GRID_VIEW_SCALING_FACTOR);
}, /**
 * Prepare for a new round of painting. Since the component
 * may be resized, compute the scaling factor again.
 */
public void preparePaint() {
    if (!size.equals(getSize())) {
        // if the size has changed...
        size = getSize();
        fieldImage = fieldView.createImage(size.width, size.height);
        g = fieldImage.getGraphics();
        xScale = size.width / gridWidth;
        if (xScale < 1) {
            xScale = GRID_VIEW_SCALING_FACTOR;
        }
        yScale = size.height / gridHeight;
        if (yScale < 1) {
            yScale = GRID_VIEW_SCALING_FACTOR;
        }
    }
}, /**
 * Paint on grid location on this field in a given color.
 */
public void drawMark(int x, int y, Color color) {
    g.setColor(color);
    g.fillRect(x * xScale, y * yScale, xScale - 1, yScale - 1);
}, /**
 * The field view component needs to be redisplayed. Copy the
 * internal image to screen.
 */
public void paintComponent(Graphics g) {
    if (fieldImage != null) {
        Dimension currentSize = getSize();
        if (size.equals(currentSize)) {
            g.drawImage(fieldImage, 0, 0, null);
        } else {
            // Rescale the previous image.
            g.drawImage(fieldImage, 0, 0, currentSize.width, currentSize.height, null);
        }
    }
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Location.java
Class Name: LocationTP: [// Row and column positions.
private int row;, private int col;, /**
 * Represent a row and column.
 * @param row The row.
 * @param col The column.
 */
public Location(int row, int col) {
    this.row = row;
    this.col = col;
}, /**
 * Implement content equality.
 */
public boolean equals(Object obj) {
    if (obj instanceof Location) {
        Location other = (Location) obj;
        return row == other.getRow() && col == other.getCol();
    } else {
        return false;
    }
}, /**
 * Return a string of the form row,column
 * @return A string representation of the location.
 */
public String toString() {
    return row + "," + col;
}, /**
 * Use the top 16 bits for the row value and the bottom for
 * the column. Except for very big grids, this should give a
 * unique hash code for each (row, col) pair.
 * @return A hashcode for the location.
 */
public int hashCode() {
    return (row << 16) + col;
}, /**
 * @return The row.
 */
public int getRow() {
    return row;
}, /**
 * @return The column.
 */
public int getCol() {
    return col;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Rabbit.java
Class Name: RabbitTP: [// Characteristics shared by all rabbits (class variables).
// The age at which a rabbit can start to breed.
private static final int BREEDING_AGE = 5;, // The age to which a rabbit can live.
private static final int MAX_AGE = 40;, // The likelihood of a rabbit breeding.
private static final double BREEDING_PROBABILITY = 0.12;, // The maximum number of births.
private static final int MAX_LITTER_SIZE = 4;, // A shared random number generator to control breeding.
private static final Random rand = Randomizer.getRandom();, // Individual characteristics (instance fields).
// The rabbit's age.
private int age;, /**
 * Create a new rabbit. A rabbit may be created with age
 * zero (a new born) or with a random age.
 *
 * @param randomAge If true, the rabbit will have a random age.
 * @param field The field currently occupied.
 * @param location The location within the field.
 */
public Rabbit(boolean randomAge, Field field, Location location) {
    super(field, location);
    age = 0;
    if (randomAge) {
        age = rand.nextInt(MAX_AGE);
    }
}, /**
 * This is what the rabbit does most of the time - it runs
 * around. Sometimes it will breed or die of old age.
 * @param newRabbits A list to return newly born rabbits.
 */
public void act(List<Animal> newRabbits) {
    incrementAge();
    if (isAlive()) {
        giveBirth(newRabbits);
        // Try to move into a free location.
        Location newLocation = getField().freeAdjacentLocation(getLocation());
        if (newLocation != null) {
            setLocation(newLocation);
        } else {
            // Overcrowding.
            setDead();
        }
    }
}, /**
 * Increase the age.
 * This could result in the rabbit's death.
 */
private void incrementAge() {
    age++;
    if (age > MAX_AGE) {
        setDead();
    }
}, /**
 * Check whether or not this rabbit is to give birth at this step.
 * New births will be made into free adjacent locations.
 * @param newRabbits A list to return newly born rabbits.
 */
private void giveBirth(List<Animal> newRabbits) {
    // New rabbits are born into adjacent locations.
    // Get a list of adjacent free locations.
    Field field = getField();
    List<Location> free = field.getFreeAdjacentLocations(getLocation());
    int births = breed();
    for (int b = 0; b < births && free.size() > 0; b++) {
        Location loc = free.remove(0);
        Rabbit young = new Rabbit(false, field, loc);
        newRabbits.add(young);
    }
}, /**
 * Generate a number representing the number of births,
 * if it can breed.
 * @return The number of births (may be zero).
 */
private int breed() {
    int births = 0;
    if (canBreed() && rand.nextDouble() <= BREEDING_PROBABILITY) {
        births = rand.nextInt(MAX_LITTER_SIZE) + 1;
    }
    return births;
}, /**
 * A rabbit can breed if it has reached the breeding age.
 * @return true if the rabbit can breed, false otherwise.
 */
private boolean canBreed() {
    return age >= BREEDING_AGE;
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Randomizer.java
Class Name: RandomizerTP: [// The default seed for control of randomization.
private static final int SEED = 1111;, // A shared Random object, if required.
private static final Random rand = new Random(SEED);, // Determine whether a shared random generator is to be provided.
private static final boolean useShared = true;, /**
 * Constructor for objects of class Randomizer
 */
public Randomizer() {
}, /**
 * Provide a random generator.
 * @return A random object.
 */
public static Random getRandom() {
    if (useShared) {
        return rand;
    } else {
        return new Random();
    }
}, /**
 * Reset the randomization.
 * This will have no effect if randomization is not through
 * a shared Random generator.
 */
public static void reset() {
    if (useShared) {
        rand.setSeed(SEED);
    }
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\Simulator.java
Class Name: SimulatorTP: [// Constants representing configuration information for the simulation.
// The default width for the grid.
private static final int DEFAULT_WIDTH = 120;, // The default depth of the grid.
private static final int DEFAULT_DEPTH = 80;, // The probability that a fox will be created in any given grid position.
private static final double FOX_CREATION_PROBABILITY = 0.02;, // The probability that a rabbit will be created in any given grid position.
private static final double RABBIT_CREATION_PROBABILITY = 0.08;, // List of animals in the field.
private List<Animal> animals;, // The current state of the field.
private Field field;, // The current step of the simulation.
private int step;, // A graphical view of the simulation.
private List<SimulatorView> views;, /**
 * Construct a simulation field with default size.
 */
public Simulator() {
    this(DEFAULT_DEPTH, DEFAULT_WIDTH);
}, /**
 * Create a simulation field with the given size.
 * @param depth Depth of the field. Must be greater than zero.
 * @param width Width of the field. Must be greater than zero.
 */
public Simulator(int depth, int width) {
    if (width <= 0 || depth <= 0) {
        System.out.println("The dimensions must be greater than zero.");
        System.out.println("Using default values.");
        depth = DEFAULT_DEPTH;
        width = DEFAULT_WIDTH;
    }
    animals = new ArrayList<>();
    field = new Field(depth, width);
    views = new ArrayList<>();
    SimulatorView view = new GridView(depth, width);
    view.setColor(Rabbit.class, Color.ORANGE);
    view.setColor(Fox.class, Color.BLUE);
    views.add(view);
    view = new GraphView(500, 150, 500);
    view.setColor(Rabbit.class, Color.BLACK);
    view.setColor(Fox.class, Color.RED);
    views.add(view);
    // Setup a valid starting point.
    reset();
}, /**
 * Run the simulation from its current state for a reasonably long period,
 * (4000 steps).
 */
public void runLongSimulation() {
    simulate(4000);
}, /**
 * Run the simulation from its current state for the given number of steps.
 * Stop before the given number of steps if it ceases to be viable.
 * @param numSteps The number of steps to run for.
 */
public void simulate(int numSteps) {
    for (int step = 1; step <= numSteps && views.get(0).isViable(field); step++) {
        simulateOneStep();
    // delay(60);   // uncomment this to run more slowly
    }
}, /**
 * Run the simulation from its current state for a single step.
 * Iterate over the whole field updating the state of each
 * fox and rabbit.
 */
public void simulateOneStep() {
    step++;
    // Provide space for newborn animals.
    List<Animal> newAnimals = new ArrayList<>();
    // Let all rabbits act.
    for (Iterator<Animal> it = animals.iterator(); it.hasNext(); ) {
        Animal animal = it.next();
        animal.act(newAnimals);
        if (!animal.isAlive()) {
            it.remove();
        }
    }
    // Add the newly born foxes and rabbits to the main lists.
    animals.addAll(newAnimals);
    updateViews();
}, /**
 * Reset the simulation to a starting position.
 */
public void reset() {
    step = 0;
    animals.clear();
    for (SimulatorView view : views) {
        view.reset();
    }
    populate();
    updateViews();
}, /**
 * Update all existing views.
 */
private void updateViews() {
    for (SimulatorView view : views) {
        view.showStatus(step, field);
    }
}, /**
 * Randomly populate the field with foxes and rabbits.
 */
private void populate() {
    Random rand = Randomizer.getRandom();
    field.clear();
    for (int row = 0; row < field.getDepth(); row++) {
        for (int col = 0; col < field.getWidth(); col++) {
            if (rand.nextDouble() <= FOX_CREATION_PROBABILITY) {
                Location location = new Location(row, col);
                Fox fox = new Fox(true, field, location);
                animals.add(fox);
            } else if (rand.nextDouble() <= RABBIT_CREATION_PROBABILITY) {
                Location location = new Location(row, col);
                Rabbit rabbit = new Rabbit(true, field, location);
                animals.add(rabbit);
            }
        // else leave the location empty.
        }
    }
}, /**
 * Pause for a given time.
 * @param millisec  The time to pause for, in milliseconds
 */
private void delay(int millisec) {
    try {
        Thread.sleep(millisec);
    } catch (InterruptedException ie) {
    // wake up
    }
}]File: rsrc\CS409TestSystem2020\foxes-and-rabbits-graph\SimulatorView.java
Class Name: SimulatorViewTP: [/**
 * Define a color to be used for a given class of animal.
 * @param animalClass The animal's Class object.
 * @param color The color to be used for the given class.
 */
void setColor(Class<?> animalClass, Color color);, /**
 * Determine whether the simulation should continue to run.
 * @return true If there is more than one species alive.
 */
boolean isViable(Field field);, /**
 * Show the current status of the field.
 * @param step Which iteration step it is.
 * @param field The field whose status is to be displayed.
 */
void showStatus(int step, Field field);, /**
 * Prepare for a new run.
 */
void reset();]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Actor.java
Class Name: ActorTP: [/**
 * Implement the actor's behavior.
 */
public void act();]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\City.java
Class Name: CityTP: [private List<Item> items;, private int width;, private int height;, private static final int DEFAULT_WIDTH = 35;, private static final int DEFAULT_HEIGHT = 35;, /**
 * Constructor for objects of class City
 * @param width The city's width.
 * @param height The city's height.
 */
public City(int width, int height) {
    if (width < 1) {
        throw new IllegalArgumentException("Width must be positive: " + width);
    }
    if (height < 1) {
        throw new IllegalArgumentException("Height must be positive: " + height);
    }
    this.width = width;
    this.height = height;
    items = new LinkedList<>();
}, /**
 * Create a city of default size.
 */
public City() {
    this(DEFAULT_WIDTH, DEFAULT_HEIGHT);
}, /**
 * @return An iterator over the items.
 */
public Iterator<Item> getItems() {
    return items.iterator();
}, /**
 * Add the given item to the city's collection.
 * @param item The item to be added.
 */
public void addItem(Item item) {
    if (items.contains(item)) {
        throw new IllegalArgumentException(item + " already recorded in the city.");
    }
    items.add(item);
}, /**
 * Remove the given item from the city's collection.
 * @param item The item to be removed.
 */
public void removeItem(Item item) {
    if (!items.remove(item)) {
        throw new IllegalArgumentException(item + " is not in the city.");
    }
}, /**
 * @return A string representation of the city.
 */
public String toString() {
    return "City size " + width + " by " + height;
}, /**
 * @return The width.
 */
public int getWidth() {
    return width;
}, /**
 * @return The height.
 */
public int getHeight() {
    return height;
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\CityGUI.java
Class Name: CityGUITP: [// The dimensions of the GUI.
public static final int CITY_VIEW_WIDTH = 600;, public static final int CITY_VIEW_HEIGHT = 600;, private City city;, private CityView cityView;, /**
 * Constructor for objects of class CityGUI
 * @param city The city whose state is to be displayed.
 */
public CityGUI(City city) {
    this.city = city;
    cityView = new CityView(city.getWidth(), city.getHeight());
    getContentPane().add(cityView);
    setTitle("Taxiville");
    setSize(CITY_VIEW_WIDTH, CITY_VIEW_HEIGHT);
    setVisible(true);
    cityView.preparePaint();
    cityView.repaint();
}, /**
 * Display the current state of the city.
 */
public void act() {
    cityView.preparePaint();
    Iterator<Item> items = city.getItems();
    while (items.hasNext()) {
        Item item = items.next();
        if (item instanceof DrawableItem) {
            DrawableItem drawable = (DrawableItem) item;
            Location location = item.getLocation();
            cityView.drawImage(location.getX(), location.getY(), drawable.getImage());
        }
    }
    cityView.repaint();
}, /**
 * Provide a graphical view of a rectangular city. This is
 * a nested class (a class defined inside a class) which
 * defines a custom component for the user interface. This
 * component displays the city.
 * This is rather advanced GUI stuff - you can ignore this
 * for your project if you like.
 */
private class CityView extends JPanel {

    private final int VIEW_SCALING_FACTOR = 6;

    private int cityWidth, cityHeight;

    private int xScale, yScale;

    private Dimension size;

    private Graphics g;

    private Image cityImage;

    /**
     * Create a new CityView component.
     */
    public CityView(int width, int height) {
        cityWidth = width;
        cityHeight = height;
        setBackground(Color.white);
        size = new Dimension(0, 0);
    }

    /**
     * Tell the GUI manager how big we would like to be.
     */
    public Dimension getPreferredSize() {
        return new Dimension(cityWidth * VIEW_SCALING_FACTOR, cityHeight * VIEW_SCALING_FACTOR);
    }

    /**
     * Prepare for a new round of painting. Since the component
     * may be resized, compute the scaling factor again.
     */
    public void preparePaint() {
        if (!size.equals(getSize())) {
            // if the size has changed...
            size = getSize();
            cityImage = cityView.createImage(size.width, size.height);
            g = cityImage.getGraphics();
            xScale = size.width / cityWidth;
            if (xScale < 1) {
                xScale = VIEW_SCALING_FACTOR;
            }
            yScale = size.height / cityHeight;
            if (yScale < 1) {
                yScale = VIEW_SCALING_FACTOR;
            }
        }
        g.setColor(Color.white);
        g.fillRect(0, 0, size.width, size.height);
        g.setColor(Color.gray);
        for (int i = 0, x = 0; x < size.width; i++, x = i * xScale) {
            g.drawLine(x, 0, x, size.height - 1);
        }
        for (int i = 0, y = 0; y < size.height; i++, y = i * yScale) {
            g.drawLine(0, y, size.width - 1, y);
        }
    }

    /**
     * Draw the image for a particular item.
     */
    public void drawImage(int x, int y, Image image) {
        g.drawImage(image, x * xScale + 1, y * yScale + 1, xScale - 1, yScale - 1, this);
    }

    /**
     * The city view component needs to be redisplayed. Copy the
     * internal image to screen.
     */
    public void paintComponent(Graphics g) {
        if (cityImage != null) {
            Dimension currentSize = getSize();
            if (size.equals(currentSize)) {
                g.drawImage(cityImage, 0, 0, null);
            } else {
                // Rescale the previous image.
                g.drawImage(cityImage, 0, 0, currentSize.width, currentSize.height, null);
            }
        }
    }
}]Class Name: CityViewTP: [private final int VIEW_SCALING_FACTOR = 6;, private int cityWidth, cityHeight;, private int xScale, yScale;, private Dimension size;, private Graphics g;, private Image cityImage;, /**
 * Create a new CityView component.
 */
public CityView(int width, int height) {
    cityWidth = width;
    cityHeight = height;
    setBackground(Color.white);
    size = new Dimension(0, 0);
}, /**
 * Tell the GUI manager how big we would like to be.
 */
public Dimension getPreferredSize() {
    return new Dimension(cityWidth * VIEW_SCALING_FACTOR, cityHeight * VIEW_SCALING_FACTOR);
}, /**
 * Prepare for a new round of painting. Since the component
 * may be resized, compute the scaling factor again.
 */
public void preparePaint() {
    if (!size.equals(getSize())) {
        // if the size has changed...
        size = getSize();
        cityImage = cityView.createImage(size.width, size.height);
        g = cityImage.getGraphics();
        xScale = size.width / cityWidth;
        if (xScale < 1) {
            xScale = VIEW_SCALING_FACTOR;
        }
        yScale = size.height / cityHeight;
        if (yScale < 1) {
            yScale = VIEW_SCALING_FACTOR;
        }
    }
    g.setColor(Color.white);
    g.fillRect(0, 0, size.width, size.height);
    g.setColor(Color.gray);
    for (int i = 0, x = 0; x < size.width; i++, x = i * xScale) {
        g.drawLine(x, 0, x, size.height - 1);
    }
    for (int i = 0, y = 0; y < size.height; i++, y = i * yScale) {
        g.drawLine(0, y, size.width - 1, y);
    }
}, /**
 * Draw the image for a particular item.
 */
public void drawImage(int x, int y, Image image) {
    g.drawImage(image, x * xScale + 1, y * yScale + 1, xScale - 1, yScale - 1, this);
}, /**
 * The city view component needs to be redisplayed. Copy the
 * internal image to screen.
 */
public void paintComponent(Graphics g) {
    if (cityImage != null) {
        Dimension currentSize = getSize();
        if (size.equals(currentSize)) {
            g.drawImage(cityImage, 0, 0, null);
        } else {
            // Rescale the previous image.
            g.drawImage(cityImage, 0, 0, currentSize.width, currentSize.height, null);
        }
    }
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\DrawableItem.java
Class Name: DrawableItemTP: [public Image getImage();]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Item.java
Class Name: ItemTP: [public Location getLocation();]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Location.java
Class Name: LocationTP: [private int x;, private int y;, /**
 * Model a location in the city.
 * @param x The x coordinate. Must be positive.
 * @param y The y coordinate. Must be positive.
 * @throws IllegalArgumentException If a coordinate is negative.
 */
public Location(int x, int y) {
    if (x < 0) {
        throw new IllegalArgumentException("Negative x-coordinate: " + x);
    }
    if (y < 0) {
        throw new IllegalArgumentException("Negative y-coordinate: " + y);
    }
    this.x = x;
    this.y = y;
}, /**
 * Generate the next location to visit in order to
 * reach the destination.
 * @param destination Where we want to get to.
 * @return A location in a direct line from this to
 *         destination.
 */
public Location nextLocation(Location destination) {
    int destX = destination.getX();
    int destY = destination.getY();
    int offsetX = x < destX ? 1 : x > destX ? -1 : 0;
    int offsetY = y < destY ? 1 : y > destY ? -1 : 0;
    if (offsetX != 0 || offsetY != 0) {
        return new Location(x + offsetX, y + offsetY);
    } else {
        return destination;
    }
}, /**
 * Determine the number of movements required to get
 * from here to the destination.
 * @param destination The required destination.
 * @return The number of movement steps.
 */
public int distance(Location destination) {
    int xDist = Math.abs(destination.getX() - x);
    int yDist = Math.abs(destination.getY() - y);
    return Math.max(xDist, yDist);
}, /**
 * Implement content equality for locations.
 * @return true if this location matches the other,
 *         false otherwise.
 */
public boolean equals(Object other) {
    if (other instanceof Location) {
        Location otherLocation = (Location) other;
        return x == otherLocation.getX() && y == otherLocation.getY();
    } else {
        return false;
    }
}, /**
 * @return A representation of the location.
 */
public String toString() {
    return "location " + x + "," + y;
}, /**
 * Use the top 16 bits for the y value and the bottom for the x.
 * Except for very big grids, this should give a unique hash code
 * for each (x, y) pair.
 * @return A hashcode for the location.
 */
public int hashCode() {
    return (y << 16) + x;
}, /**
 * @return The x coordinate.
 */
public int getX() {
    return x;
}, /**
 * @return The y coordinate.
 */
public int getY() {
    return y;
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\MissingPassengerException.java
Class Name: MissingPassengerExceptionTP: [private Vehicle vehicle;, /**
 * Constructor for objects of class MissingPassengerException.
 * @param vehicle The vehicle expecting a passenger.
 */
public MissingPassengerException(Vehicle vehicle) {
    super("Missing passenger at pickup location.");
}, /**
 * @return The vehicle for which there was no passenger.
 */
public Vehicle getVehicle() {
    return vehicle;
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Passenger.java
Class Name: PassengerTP: [private Location pickup;, private Location destination;, private Image image;, /**
 * Constructor for objects of class Passenger
 * @param pickup The pickup location, must not be null.
 * @param destination The destination location, must not be null.
 * @throws NullPointerException If either location is null.
 */
public Passenger(Location pickup, Location destination) {
    if (pickup == null) {
        throw new NullPointerException("Pickup location");
    }
    if (destination == null) {
        throw new NullPointerException("Destination location");
    }
    this.pickup = pickup;
    this.destination = destination;
    // Load the image used to represent a person.
    image = new ImageIcon(getClass().getResource("images/person.jpg")).getImage();
}, /**
 * @return A string representation of this person.
 */
public String toString() {
    return "Passenger travelling from " + pickup + " to " + destination;
}, /**
 * @return The image to be displayed on a GUI.
 */
public Image getImage() {
    return image;
}, /**
 * @return The passenger's pickup location.
 */
public Location getLocation() {
    return pickup;
}, /**
 * @return The pickup location.
 */
public Location getPickupLocation() {
    return pickup;
}, /**
 * @return The destination location.
 */
public Location getDestination() {
    return destination;
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\PassengerSource.java
Class Name: PassengerSourceTP: [private City city;, private TaxiCompany company;, private Random rand;, private static final double CREATION_PROBABILITY = 0.06;, private int missedPickups;, /**
 * Constructor for objects of class PassengerSource.
 * @param city The city. Must not be null.
 * @param company The company to be used. Must not be null.
 * @throws NullPointerException if city or company is null.
 */
public PassengerSource(City city, TaxiCompany company) {
    if (city == null) {
        throw new NullPointerException("city");
    }
    if (company == null) {
        throw new NullPointerException("company");
    }
    this.city = city;
    this.company = company;
    // Use a fixed random seed for repeatable effects.
    // Change this to produce more random effects.
    rand = new Random(12345);
    missedPickups = 0;
}, /**
 * Randomly generate a new passenger.
 * Keep a count of missed pickups.
 */
public void act() {
    if (rand.nextDouble() <= CREATION_PROBABILITY) {
        Passenger passenger = createPassenger();
        if (company.requestPickup(passenger)) {
            city.addItem(passenger);
        } else {
            missedPickups++;
        }
    }
}, /**
 * @return The number of passengers for whom a pickup
 *         could not be found.
 */
public int getMissedPickups() {
    return missedPickups;
}, /**
 * Create a new passenger with distinct pickup and
 * destination locations.
 * @return The created passenger.
 */
private Passenger createPassenger() {
    int cityWidth = city.getWidth();
    int cityHeight = city.getHeight();
    Location pickupLocation = new Location(rand.nextInt(cityWidth), rand.nextInt(cityHeight));
    Location destination;
    do {
        destination = new Location(rand.nextInt(cityWidth), rand.nextInt(cityHeight));
    } while (pickupLocation.equals(destination));
    return new Passenger(pickupLocation, destination);
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Shuttle.java
Class Name: ShuttleTP: [// The list of destinations for the shuttle.
private List<Location> destinations;, // The list of passengers on the shuttle.
private List<Passenger> passengers;, /**
 * Constructor for objects of class Shuttle
 * @param company The taxi company. Must not be null.
 * @param location The vehicle's starting point. Must not be null.
 * @throws NullPointerException If company or location is null.
 */
public Shuttle(TaxiCompany company, Location location) {
    super(company, location);
    destinations = new LinkedList<>();
    passengers = new LinkedList<>();
}, /**
 * Carry out a shuttle's actions.
 */
public void act() {
}, /**
 * Is the shuttle free?
 * @return Whether or not this vehicle is free.
 */
public boolean isFree() {
    return true;
}, /**
 * Receive a pickup location.
 * @param location The pickup location.
 */
public void setPickupLocation(Location location) {
    destinations.add(location);
    chooseTargetLocation();
}, /**
 * Receive a passenger.
 * Add their destination to the list.
 * @param passenger The passenger.
 */
public void pickup(Passenger passenger) {
    passengers.add(passenger);
    destinations.add(passenger.getDestination());
    chooseTargetLocation();
}, /**
 * Decide where to go next, based on the list of
 * possible destinations.
 */
private void chooseTargetLocation() {
}, /**
 * Offload a passenger whose destination is the
 * current location.
 */
public void offloadPassenger() {
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Simulation.java
Class Name: SimulationTP: [private List<Actor> actors;, private int step;, /**
 * Create the initial set of actors for the simulation.
 */
public Simulation() {
    actors = new LinkedList<>();
    step = 0;
    City city = new City();
    TaxiCompany company = new TaxiCompany(city);
    PassengerSource source = new PassengerSource(city, company);
    actors.addAll(company.getVehicles());
    actors.add(source);
    actors.add(new CityGUI(city));
}, /**
 * Run the simulation for a fixed number of steps.
 * Pause after each step to allow the GUI to keep up.
 */
public void run() {
    for (int i = 0; i < 500; i++) {
        step++;
        step();
        wait(100);
    }
}, /**
 * Take a single step of the simulation.
 */
public void step() {
    for (Actor actor : actors) {
        actor.act();
    }
}, /**
 * Wait for a specified number of milliseconds before finishing.
 * This provides an easy way to cause a small delay.
 * @param milliseconds The number of milliseconds to wait.
 */
private void wait(int milliseconds) {
    try {
        Thread.sleep(milliseconds);
    } catch (InterruptedException e) {
    // ignore the exception
    }
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Taxi.java
Class Name: TaxiTP: [private Passenger passenger;, // Maintain separate images for when the taxi is empty
// and full.
private Image emptyImage, passengerImage;, /**
 * Constructor for objects of class Taxi
 * @param company The taxi company. Must not be null.
 * @param location The vehicle's starting point. Must not be null.
 * @throws NullPointerException If company or location is null.
 */
public Taxi(TaxiCompany company, Location location) {
    super(company, location);
    // Load the two images.
    emptyImage = new ImageIcon(getClass().getResource("images/taxi.jpg")).getImage();
    passengerImage = new ImageIcon(getClass().getResource("images/taxi+person.jpg")).getImage();
}, /**
 * Move towards the target location if we have one.
 * Otherwise record that we are idle.
 */
public void act() {
    Location target = getTargetLocation();
    if (target != null) {
        // Find where to move to next.
        Location next = getLocation().nextLocation(target);
        setLocation(next);
        if (next.equals(target)) {
            if (passenger != null) {
                notifyPassengerArrival(passenger);
                offloadPassenger();
            } else {
                notifyPickupArrival();
            }
        }
    } else {
        incrementIdleCount();
    }
}, /**
 * Is the taxi free?
 * @return Whether or not this taxi is free.
 */
public boolean isFree() {
    return getTargetLocation() == null && passenger == null;
}, /**
 * Receive a pickup location. This becomes the
 * target location.
 * @param location The pickup location.
 */
public void setPickupLocation(Location location) {
    setTargetLocation(location);
}, /**
 * Receive a passenger.
 * Set their destination as the target location.
 * @param passenger The passenger.
 */
public void pickup(Passenger passenger) {
    this.passenger = passenger;
    setTargetLocation(passenger.getDestination());
}, /**
 * Offload the passenger.
 */
public void offloadPassenger() {
    passenger = null;
    clearTargetLocation();
}, /**
 * Return an image that describes our state:
 * either empty or carrying a passenger.
 */
public Image getImage() {
    if (passenger != null) {
        return passengerImage;
    } else {
        return emptyImage;
    }
}, /**
 * Return details of the taxi, such as where it is.
 * @return A string representation of the taxi.
 */
public String toString() {
    return "Taxi at " + getLocation();
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\TaxiCompany.java
Class Name: TaxiCompanyTP: [// The vehicles operated by the company.
private List<Vehicle> vehicles;, private City city;, // The associations between vehicles and the passengers
// they are to pick up.
private Map<Vehicle, Passenger> assignments;, private static final int NUMBER_OF_TAXIS = 3;, /**
 * @param city The city.
 */
public TaxiCompany(City city) {
    this.city = city;
    vehicles = new LinkedList<>();
    assignments = new HashMap<>();
    setupVehicles();
}, /**
 * Request a pickup for the given passenger.
 * @param passenger The passenger requesting a pickup.
 * @return Whether a free vehicle is available.
 */
public boolean requestPickup(Passenger passenger) {
    Vehicle vehicle = scheduleVehicle();
    if (vehicle != null) {
        assignments.put(vehicle, passenger);
        vehicle.setPickupLocation(passenger.getPickupLocation());
        return true;
    } else {
        return false;
    }
}, /**
 * A vehicle has arrived at a pickup point.
 * @param vehicle The vehicle at the pickup point.
 * @throws MissingPassengerException If there is no passenger waiting.
 */
public void arrivedAtPickup(Vehicle vehicle) {
    Passenger passenger = assignments.remove(vehicle);
    if (passenger == null) {
        throw new MissingPassengerException(vehicle);
    }
    city.removeItem(passenger);
    vehicle.pickup(passenger);
}, /**
 * A vehicle has arrived at a passenger's destination.
 * @param vehicle The vehicle at the destination.
 * @param passenger The passenger being dropped off.
 */
public void arrivedAtDestination(Vehicle vehicle, Passenger passenger) {
}, /**
 * @return The list of vehicles.
 */
public List<Vehicle> getVehicles() {
    return vehicles;
}, /**
 * Find a free vehicle, if any.
 * @return A free vehicle, or null if there is none.
 */
private Vehicle scheduleVehicle() {
    Iterator<Vehicle> it = vehicles.iterator();
    while (it.hasNext()) {
        Vehicle vehicle = it.next();
        if (vehicle.isFree()) {
            return vehicle;
        }
    }
    return null;
}, /**
 * Set up this company's vehicles. The optimum number of
 * vehicles should be determined by analysis of the
 * data gathered from the simulation.
 *
 * Vehicles start at random locations.
 */
private void setupVehicles() {
    int cityWidth = city.getWidth();
    int cityHeight = city.getHeight();
    // Used a fixed random seed for predictable behavior.
    // Use different seeds for less predictable behavior.
    Random rand = new Random(12345);
    // Create the taxis.
    for (int i = 0; i < NUMBER_OF_TAXIS; i++) {
        Taxi taxi = new Taxi(this, new Location(rand.nextInt(cityWidth), rand.nextInt(cityHeight)));
        vehicles.add(taxi);
        city.addItem(taxi);
    }
}]File: rsrc\CS409TestSystem2020\taxi-company-later-stage\Vehicle.java
Class Name: VehicleTP: [private TaxiCompany company;, // Where the vehicle is.
private Location location;, // Where the vehicle is headed.
private Location targetLocation;, // Record how often the vehicle has nothing to do.
private int idleCount;, /**
 * Constructor of class Vehicle
 * @param company The taxi company. Must not be null.
 * @param location The vehicle's starting point. Must not be null.
 * @throws NullPointerException If company or location is null.
 */
public Vehicle(TaxiCompany company, Location location) {
    if (company == null) {
        throw new NullPointerException("company");
    }
    if (location == null) {
        throw new NullPointerException("location");
    }
    this.company = company;
    this.location = location;
    targetLocation = null;
    idleCount = 0;
}, /**
 * Notify the company of our arrival at a pickup location.
 */
public void notifyPickupArrival() {
    company.arrivedAtPickup(this);
}, /**
 * Notify the company of our arrival at a
 * passenger's destination.
 */
public void notifyPassengerArrival(Passenger passenger) {
    company.arrivedAtDestination(this, passenger);
}, /**
 * Receive a pickup location.
 * How this is handled depends on the type of vehicle.
 * @param location The pickup location.
 */
public abstract void setPickupLocation(Location location);, /**
 * Receive a passenger.
 * How this is handled depends on the type of vehicle.
 * @param passenger The passenger.
 */
public abstract void pickup(Passenger passenger);, /**
 * Is the vehicle free?
 * @return Whether or not this vehicle is free.
 */
public abstract boolean isFree();, /**
 * Offload any passengers whose destination is the
 * current location.
 */
public abstract void offloadPassenger();, /**
 * @return Where this vehicle is currently located.
 */
public Location getLocation() {
    return location;
}, /**
 * Set the current location.
 * @param location Where it is. Must not be null.
 * @throws NullPointerException If location is null.
 */
public void setLocation(Location location) {
    if (location != null) {
        this.location = location;
    } else {
        throw new NullPointerException();
    }
}, /**
 * Get the target location.
 * @return Where this vehicle is currently headed, or null
 *         if it is idle.
 */
public Location getTargetLocation() {
    return targetLocation;
}, /**
 * Set the required target location.
 * @param location Where to go. Must not be null.
 * @throws NullPointerException If location is null.
 */
public void setTargetLocation(Location location) {
    if (location != null) {
        targetLocation = location;
    } else {
        throw new NullPointerException();
    }
}, /**
 * Clear the target location.
 */
public void clearTargetLocation() {
    targetLocation = null;
}, /**
 * @return On how many steps this vehicle has been idle.
 */
public int getIdleCount() {
    return idleCount;
}, /**
 * Increment the number of steps on which this vehicle
 * has been idle.
 */
public void incrementIdleCount() {
    idleCount++;
}]File: rsrc\CS409TestSystem2020\weblog-analyzer\LogAnalyzer.java
Class Name: LogAnalyzerTP: [// Where to calculate the hourly access counts.
private int[] hourCounts;, // Use a LogfileReader to access the data.
private LogfileReader reader;, /**
 * Create an object to analyze hourly web accesses.
 */
public LogAnalyzer() {
    // Create the array object to hold the hourly
    // access counts.
    hourCounts = new int[24];
    // Create the reader to obtain the data.
    reader = new LogfileReader();
}, /**
 * Analyze the hourly access data from the log file.
 */
public void analyzeHourlyData() {
    while (reader.hasNext()) {
        LogEntry entry = reader.next();
        int hour = entry.getHour();
        hourCounts[hour]++;
    }
}, /**
 * Print the hourly counts.
 * These should have been set with a prior
 * call to analyzeHourlyData.
 */
public void printHourlyCounts() {
    System.out.println("Hr: Count");
    for (int hour = 0; hour < hourCounts.length; hour++) {
        System.out.println(hour + ": " + hourCounts[hour]);
    }
}, /**
 * Print the lines of data read by the LogfileReader
 */
public void printData() {
    reader.printData();
}]File: rsrc\CS409TestSystem2020\weblog-analyzer\LogEntry.java
Class Name: LogEntryTP: [// Where the data values extracted from a single
// log line are stored.
private int[] dataValues;, // The equivalent Calendar object for the log time.
private Calendar when;, // At which index in dataValues the different fields
// from a log line are stored.
private static final int YEAR = 0, MONTH = 1, DAY = 2, HOUR = 3, MINUTE = 4;, // The number of fields. If more fields are added, e.g. for
// seconds or a status code, then this value must be increased
// to match.
private static final int NUMBER_OF_FIELDS = 5;, /**
 * Decompose a log line so that the individual fields
 * are available.
 * @param logline A single line from the log.
 *                This should be in the format:
 *                year month day hour minute etc.
 */
public LogEntry(String logline) {
    // The array to store the data for a single line.
    dataValues = new int[NUMBER_OF_FIELDS];
    // Break up the log line.
    LoglineTokenizer tokenizer = new LoglineTokenizer();
    tokenizer.tokenize(logline, dataValues);
    setWhen();
}, /**
 * Create a LogEntry from the individual components.
 * @param year The year
 * @param month The month (1-12)
 * @param day The day (1-31)
 * @param hour The hour (0-23)
 * @param minute The minute (0-59)
 */
public LogEntry(int year, int month, int day, int hour, int minute) {
    // The array to store the data for a single line.
    dataValues = new int[NUMBER_OF_FIELDS];
    dataValues[YEAR] = year;
    dataValues[MONTH] = month;
    dataValues[DAY] = day;
    dataValues[HOUR] = hour;
    dataValues[MINUTE] = minute;
    setWhen();
}, /**
 * Return the hour.
 * @return The hour field from the log line.
 */
public int getHour() {
    return dataValues[HOUR];
}, /**
 * Return the minute.
 * @return The minute field from the log line.
 */
public int getMinute() {
    return dataValues[MINUTE];
}, /**
 * Create a string representation of the data.
 * This is not necessarily identical with the
 * text of the original log line.
 * @return A string representing the data of this entry.
 */
public String toString() {
    StringBuffer buffer = new StringBuffer();
    for (int value : dataValues) {
        // Prefix a leading zero on single digit numbers.
        if (value < 10) {
            buffer.append('0');
        }
        buffer.append(value);
        buffer.append(' ');
    }
    // Drop any trailing space.
    return buffer.toString().trim();
}, /**
 * Compare the date/time combination of this log entry
 * with another.
 * @param otherEntry The other entry to compare against.
 * @return A negative value if this entry comes before the other.
 *         A positive value if this entry comes after the other.
 *         Zero if the entries are the same.
 */
public int compareTo(LogEntry otherEntry) {
    // Use the equivalent Calendars comparison method.
    return when.compareTo(otherEntry.getWhen());
}, /**
 * Return the Calendar object representing this event.
 * @return The Calendar for this event.
 */
private Calendar getWhen() {
    return when;
}, /**
 * Create an equivalent Calendar object from the data values.
 */
private void setWhen() {
    when = Calendar.getInstance();
    // Adjust from 1-based month and day to 0-based.
    when.set(dataValues[YEAR], dataValues[MONTH] - 1, dataValues[DAY] - 1, dataValues[HOUR], dataValues[MINUTE]);
}]File: rsrc\CS409TestSystem2020\weblog-analyzer\LogfileCreator.java
Class Name: LogfileCreatorTP: [private Random rand;, /**
 * Create log files.
 */
public LogfileCreator() {
    rand = new Random();
}, /**
 * Create a file of random log entries.
 * @param filename The file to write.
 * @param numEntries How many entries.
 * @return true if successful, false otherwise.
 */
public boolean createFile(String filename, int numEntries) {
    boolean success = false;
    if (numEntries > 0) {
        try (FileWriter writer = new FileWriter(filename)) {
            LogEntry[] entries = new LogEntry[numEntries];
            for (int i = 0; i < numEntries; i++) {
                entries[i] = createEntry();
            }
            Arrays.sort(entries);
            for (int i = 0; i < numEntries; i++) {
                writer.write(entries[i].toString());
                writer.write('\n');
            }
            success = true;
        } catch (IOException e) {
            System.err.println("There was a problem writing to " + filename);
        }
    }
    return success;
}, /**
 * Create a single (random) entry for a log file.
 * @return A log entry containing random data.
 */
public LogEntry createEntry() {
    int year = 2016;
    int month = 1 + rand.nextInt(12);
    // Avoid the complexities of days-per-month.
    int day = 1 + rand.nextInt(28);
    int hour = rand.nextInt(24);
    int minute = rand.nextInt(60);
    return new LogEntry(year, month, day, hour, minute);
}]File: rsrc\CS409TestSystem2020\weblog-analyzer\LogfileReader.java
Class Name: LogfileReaderTP: [// The data format in the log file.
private String format;, // Where the file's contents are stored in the form
// of LogEntry objects.
private ArrayList<LogEntry> entries;, // An iterator over entries.
private Iterator<LogEntry> dataIterator;, /**
 * Create a LogfileReader to supply data from a default file.
 */
public LogfileReader() {
    this("weblog.txt");
}, /**
 * Create a LogfileReader that will supply data
 * from a particular log file.
 * @param filename The file of log data.
 */
public LogfileReader(String filename) {
    // The format for the data.
    format = "Year Month(1-12) Day Hour Minute";
    // Where to store the data.
    entries = new ArrayList<>();
    // Attempt to read the complete set of data from file.
    boolean dataRead;
    try {
        // Locate the file with respect to the current environment.
        URL fileURL = getClass().getClassLoader().getResource(filename);
        if (fileURL == null) {
            throw new FileNotFoundException(filename);
        }
        Scanner logfile = new Scanner(new File(fileURL.toURI()));
        // Read the data lines until the end of file.
        while (logfile.hasNextLine()) {
            String logline = logfile.nextLine();
            // Break up the line and add it to the list of entries.
            LogEntry entry = new LogEntry(logline);
            entries.add(entry);
        }
        logfile.close();
        dataRead = true;
    } catch (FileNotFoundException | URISyntaxException e) {
        System.out.println("Problem encountered: " + e);
        dataRead = false;
    }
    // If we couldn't read the log file, use simulated data.
    if (!dataRead) {
        System.out.println("Failed to read the data file: " + filename);
        System.out.println("Using simulated data instead.");
        createSimulatedData(entries);
    }
    // Sort the entries into ascending order.
    Collections.sort(entries);
    reset();
}, /**
 * Does the reader have more data to supply?
 * @return true if there is more data available,
 *         false otherwise.
 */
public boolean hasNext() {
    return dataIterator.hasNext();
}, /**
 * Analyze the next line from the log file and
 * make it available via a LogEntry object.
 *
 * @return A LogEntry containing the data from the
 *         next log line.
 */
public LogEntry next() {
    return dataIterator.next();
}, /**
 * Remove an entry.
 * This operation is not permitted.
 */
public void remove() {
    System.err.println("It is not permitted to remove entries.");
}, /**
 * @return A string explaining the format of the data
 *         in the log file.
 */
public String getFormat() {
    return format;
}, /**
 * Set up a fresh iterator to provide access to the data.
 * This allows a single file of data to be processed
 * more than once.
 */
public void reset() {
    dataIterator = entries.iterator();
}, /**
 * Print the data.
 */
public void printData() {
    for (LogEntry entry : entries) {
        System.out.println(entry);
    }
}, /**
 * Provide a sample of simulated data.
 * NB: To simplify the creation of this data, no
 * days after the 28th of a month are ever generated.
 * @param data Where to store the simulated LogEntry objects.
 */
private void createSimulatedData(ArrayList<LogEntry> data) {
    LogfileCreator creator = new LogfileCreator();
    // How many simulated entries we want.
    int numEntries = 100;
    for (int i = 0; i < numEntries; i++) {
        data.add(creator.createEntry());
    }
}]File: rsrc\CS409TestSystem2020\weblog-analyzer\LoglineTokenizer.java
Class Name: LoglineTokenizerTP: [/**
 * Construct a LogLineAnalyzer
 */
public LoglineTokenizer() {
}, /**
 * Tokenize a log line. Place the integer values from
 * it into an array. The number of tokens on the line
 * must be sufficient to fill the array.
 *
 * @param logline The line to be tokenized.
 * @param dataLine Where to store the values.
 */
public void tokenize(String logline, int[] dataLine) {
    try {
        // Scan the logline for integers.
        Scanner tokenizer = new Scanner(logline);
        for (int i = 0; i < dataLine.length; i++) {
            dataLine[i] = tokenizer.nextInt();
        }
    } catch (java.util.NoSuchElementException e) {
        System.out.println("Insuffient data items on log line: " + logline);
        throw e;
    }
}]File: rsrc\Test.java
Class Name: exampleTP: [public example() {
    // Boolean check = false;
    if (check) {
    }
    switch(r) {
        case 0:
            return 0;
        case 1:
            return 0;
        default:
            break;
    }
    while (x == 0) {
    }
    for (int i = 0; i++; i < 5) {
    }
    for (int j : list) {
    }
    do {
    } while (x < 5);
}, public void CheckIfs(int a, int b) {
    int result = a + b;
    if (result > 0 || result == 0) {
        String colour = "red";
    } else if (result < 0) {
        String colour = "blue";
    }
    if (i < 4) {
    } else {
        return;
    }
}, public void CheckBody();, public int CheckSwitch(int x, int y) {
    int r = x;
    switch(r) {
        case x:
            r -= x;
            return r;
        case y:
            r += y;
            return r;
        default:
            break;
    }
    return r;
}, public int CheckLoops(int x, int y) {
    while (x == 0 && y > 50) {
        x++;
        while (y > 50) {
            y--;
        }
    }
    for (int i = 0; i++; i < 5) {
    }
    for (int j : list) {
    }
    do {
        x = 7;
    } while (x < 5 || x > 10);
    return x;
}]File: rsrc\VisitorDemo.java
Class Name: CarElementTP: [void accept(CarElementVisitor visitor);]Class Name: CarElementVisitorTP: [void visit(Body body);, void visit(Car car);, void visit(Engine engine);, void visit(Wheel wheel);]Class Name: WheelTP: [private final String name;, private float tyrePressure = 0f;, public Wheel(final String name, float tyrePressure) {
    this.name = name;
    this.tyrePressure = tyrePressure;
}, public String getName() {
    return name;
}, public float getTyrePressure() {
    return tyrePressure;
}, @Override
public void accept(CarElementVisitor visitor) {
    visitor.visit(this);
}]Class Name: BodyTP: [private String bodyType = "";, public Body(final String bodyType) {
    this.bodyType = bodyType;
}, @Override
public void accept(CarElementVisitor visitor) {
    visitor.visit(this);
}, public String getBodyType() {
    return bodyType;
}]Class Name: EngineTP: [private String oilLevel = "";, private String engineSize = "";, public Engine(String oilLevel, String engineSize) {
    this.oilLevel = oilLevel;
    this.engineSize = engineSize;
}, @Override
public void accept(CarElementVisitor visitor) {
    visitor.visit(this);
}, public String getOilLevel() {
    return oilLevel;
}, public String getEngineLevelSize() {
    return engineSize;
}]Class Name: CarTP: [private final List<CarElement> elements;, public Car(float fl, float fr, float bl, float br, String bT, String oL, String eS) {
    this.elements = List.of(new Wheel("front left", fl), new Wheel("front right", fr), new Wheel("back left", bl), new Wheel("back right", br), new Body(bT), new Engine(oL, eS));
}, @Override
public void accept(CarElementVisitor visitor) {
    for (CarElement element : elements) {
        element.accept(visitor);
    }
    visitor.visit(this);
}]Class Name: CarElementDoVisitorTP: [@Override
public void visit(Body body) {
    System.out.println("Moving my body");
}, @Override
public void visit(Car car) {
    System.out.println("Starting my car");
}, @Override
public void visit(Wheel wheel) {
    System.out.println("Kicking my " + wheel.getName() + " wheel");
}, @Override
public void visit(Engine engine) {
    System.out.println("Starting my engine");
}]Class Name: CarElementPrintVisitorTP: [@Override
public void visit(Body body) {
    System.out.println("Visiting body");
}, @Override
public void visit(Car car) {
    System.out.println("Visiting car");
}, @Override
public void visit(Engine engine) {
    System.out.println("Visiting engine");
}, @Override
public void visit(Wheel wheel) {
    System.out.println("Visiting " + wheel.getName() + " wheel");
}]Class Name: SalesVisitorTP: [@Override
public void visit(Body body) {
    System.out.println("The car is a " + body.getBodyType());
}, @Override
public void visit(Car car) {
    return;
}, @Override
public void visit(Engine engine) {
    System.out.println("The engine size is " + engine.getEngineLevelSize());
}, @Override
public void visit(Wheel wheel) {
    return;
}]Class Name: MechanicVisitorTP: [@Override
public void visit(Body body) {
    return;
}, @Override
public void visit(Car car) {
    return;
}, @Override
public void visit(Engine engine) {
    System.out.println("The engine oil is " + engine.getOilLevel());
}, @Override
public void visit(Wheel wheel) {
    System.out.println("The tyre pressure is " + wheel.getTyrePressure());
}]Class Name: VisitorDemoTP: [public static void main(final String[] args) {
    float[] tPress = { 30f, 30f, 30f, 30f };
    String bType = "Hatchback";
    String oLevel = "High";
    String eSize = "Big";
    for (int i = 0; i < 5; i++) {
        float[] tPress = { 30f, 30f, 30f, 30f };
        String bType = "Hatchback";
        String oLevel = "High";
        String eSize = "Big";
    }
    for (int i = 0; i < 5; i++) {
        Car car = new Car(0.5f, 0.5f, 0.5f, 0.5f, "Rover", "Low", "Small");
        car.accept(new CarElementPrintVisitor());
        car.accept(new CarElementDoVisitor());
        car.accept(new MechanicVisitor());
        car.accept(new SalesVisitor());
    }
}]